// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./Ownership.sol";
import "./Manufacturer.sol";
import "./Transporter.sol";
import "./Supplier.sol";

contract SupplyChain is Ownable,ManufacturerRole,SupplierRole,TransporterRole{

       // Define 'owner'
    address owner;

    // Define a variable called 'productCode' for Universal Product Code (productCode)
    uint256 productCode;

    // Define a variable called 'stockUnit' for Stock Keeping Unit (stockUnit)
    uint256 stockUnit;

    // Define a public mapping 'items' that maps the productCode to an Item.
    mapping(uint256 => Item) items;

    // Define a public mapping 'itemsHistory' that maps the productCode to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping(uint256 => Txblocks) itemsHistory;

    // Define enum 'State' with the following values:
    enum State {
        ProduceBySupplier,
        PurchasedByManufacturer,
        ReceivedByTransporter,
        ShippedByTransporter,
        ReceivedByManufacturer
        }
        State constant defaultState = State.ProduceBySupplier;

    struct Item{
        uint256 stockUnit; // Stock Keeping Unit (stockUnit)
        uint256 productCode; // Universal Product Code (productCode), generated by the Supplier, goes on the package, can be verified by the Manufacturer
        address ownerID; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address originSupplierID;
        uint256 productID; // Product ID potentially a combination of productCode + stockUnit
        uint256 productDate; // Product Date NOTE: MIGHT NEED TO CHANGE type
        uint256 productPrice; // Product Price
        uint256 productSliced; // Parent cheese
        State itemState; // Product State as represented in the enum above
        address ManufacturerID;
        uint256 shipDate; 
    }

        struct Txblocks {
        uint256 STT; // blockSupplierToManufacturer
        uint256 TTM; // blockManufacturerToRetailer
    }

     event ProduceBySupplier(uint256 productCode);
     event PurchasedByManufacturer(uint256 productCode);
     event ReceivedByTransporter(uint256 productCode);
     event ShippedByTransporter(uint256 productCode);
     event ReceivedByManufacturer(uint256 productCode);

     // Define a modifer that checks to see if _msgSender() == owner of the contract
    modifier only_Owner() {
        require(_msgSender() == owner);
        _;
    }

    // Define a modifer that verifies the Caller
    modifier verifyCaller(address _address) {
        require(_msgSender() == _address);
        _;
    }

    // Define a modifier that checks if the paid amount is sufficient to cover the price
    modifier paidEnough(uint256 _price) {
        require(msg.value >= _price);
        _;
    }

    // Define a modifier that checks the price and refunds the remaining balance
    modifier checkValue(uint256 _productCode, address payable addressToFund) {
        uint256 _price = items[_productCode].productPrice;
        uint256 amountToReturn = msg.value - _price;
        addressToFund.transfer(amountToReturn);
        _;
    }

     //Item State Modifiers
    modifier produceBySupplier(uint256 _productCode) {
        require(items[_productCode].itemState == State.ProduceBySupplier);
        _;
    }

     modifier purchaseByManufacturer(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByManufacturer);
        _;
    }

     modifier receivedByTransporter(uint256 _productCode) {
        require(items[_productCode].itemState == State.ReceivedByTransporter);
        _;
    }

    modifier shippedByTransporter(uint256 _productCode) {
        require(items[_productCode].itemState == State.ShippedByTransporter);
        _;
    }

    modifier receivedByManufacturer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ReceivedByManufacturer);
        _;
    }

    // constructor setup owner stockUnit productCode
    constructor() public payable {
        owner = _msgSender();
        stockUnit = 1;
        productCode = 1;
    }

    // allows you to convert an address into a payable address
    function _make_payable(address x) internal pure returns (address payable) {
        return payable(address(uint160(x)));
    }

     function produceItemBySupplier(
        uint256 _productCode,
        string memory _originSupplierName,
        uint256 _price
    )
        public
        onlySupplier // check address belongs to SupplierRole
    {
        address SupplierID; // Empty ManufacturerID address
        Item memory newProduce; // Create a new struct Item in memory
        newProduce.stockUnit = stockUnit; // Stock Keeping Unit (stockUnit)
        newProduce.productCode = _productCode; // Universal Product Code (productCode), generated by the Supplier, goes on the package, can be verified by the Consumer
        newProduce.ownerID = _msgSender(); // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        newProduce.originSupplierID = _msgSender(); // Metamask-Ethereum address of the Supplier
        newProduce.productID = _productCode + stockUnit; // Product ID
        newProduce.productPrice = _price; // Product Price
        newProduce.productDate = block.timestamp;
        newProduce.productSliced = 0;
        newProduce.itemState = defaultState; // Product State as represented in the enum above
        newProduce.originSupplierID = SupplierID; // Metamask-Ethereum address of the Manufacturer
        items[_productCode] = newProduce; // Add newProduce to items struct by productCode
        uint256 placeholder; // Block number place holder
        Txblocks memory txBlock; // create new txBlock struct
        txBlock.STT = placeholder; // assign placeholder values
        txBlock.TTM = placeholder;
        itemsHistory[_productCode] = txBlock; // add txBlock to itemsHistory mapping by productCode

        // Increment stockUnit
        stockUnit = stockUnit + 1;

        // Emit the appropriate event
        emit ProduceBySupplier(_productCode);
    }

    function purchaseItemByManufacturer(uint256 _productCode)
        public
        payable
        onlyManufacturer // check _msgSender() belongs to ManufacturerRole
        checkValue(_productCode, payable(_msgSender())) // check if overpayed return remaing funds back to _msgSender()
    {
        address payable ownerAddressPayable = _make_payable(
            items[_productCode].originSupplierID
        ); // make originFarmID payable
        ownerAddressPayable.transfer(items[_productCode].productPrice); // transfer funds from Manufacturer to Supplier
        items[_productCode].ownerID = _msgSender(); // update owner
        items[_productCode].ManufacturerID = _msgSender(); // update Manufacturer
        items[_productCode].itemState = State.PurchasedByManufacturer; // update state
        itemsHistory[_productCode].STT= block.number; // add block number
        emit PurchasedByManufacturer(_productCode);
    }

    function shippedItemByTransporter(uint256 _productCode)
        public
        payable
        onlySupplier // check _msgSender() belongs to SupplierRole
        purchaseByManufacturer(_productCode)
        verifyCaller(items[_productCode].originSupplierID) // check _msgSender() is originFarmID
    {
        items[_productCode].itemState = State.ShippedByTransporter; // update state
        emit ShippedByTransporter(_productCode);
    }


    function receivedItemByTransporter(uint256 _productCode)
        public
        onlyTransporter // check _msgSender() belongs to ManufacturerRole
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.ReceivedByTransporter; // update state
        emit ReceivedByTransporter(_productCode);
    }

    function receivedItemByManufacturer(uint256 _productCode)
        public
        onlyManufacturer // check _msgSender() belongs to ManufacturerRole
        shippedByTransporter(_productCode)
        verifyCaller(items[_productCode].ownerID) // check _msgSender() is owner
    {
        items[_productCode].itemState = State.ReceivedByManufacturer; // update state
        emit ReceivedByManufacturer(_productCode);
    }

     // Define a function 'fetchItemHistory' that fetaches the data
    function fetchitemHistory(uint256 _productCode)
        public
        view
        returns (
            uint256 blockSupplierToTransporter,
            uint256 blockTransporterToManufacturer
        )
    {
        // Assign value to the parameters
        Txblocks memory txblock = itemsHistory[_productCode];
        return (txblock.STT, txblock.TTM);
    }
}


